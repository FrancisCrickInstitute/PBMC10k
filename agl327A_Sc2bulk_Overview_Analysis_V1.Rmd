---
title: "sc2bulk Overview Analysis"
author: "Stefan Boeing"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'

output: 
    html_document:
        code_folding: hide
        df_print: tibble
        toc: true
        toc_depth: 3
        toc_float: true
        css:

always_allow_html: yes

---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
    tidy = TRUE,
    tidy.opts = list(width.cutoff = 120),
    message = FALSE,
    warning = FALSE
)
```


## Part B Database


```{r hpc_notes, include=FALSE}

# module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;R;

## Get interactive session ##
#  srun --time=08:00:00 --mem=40G -p int --pty bash

# module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;R;

# sbatch --time=12:00:00 --wrap "module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;Rscript runD.r" --job-name="rD" -p hmem --mem=300G -o rD.slurm >> commands.txt

# --mem-per-cpu=14G -p hmem --pty bash

```


```{r populate_meta_data_database, eval=TRUE, echo=F, results=F}
###############################################################################
## Load single-cell project, transform into bulk project and process         ##

##                                                                           ##
###############################################################################


###############################################################################
## Initiate Analysis                                                         ##

library(tidyverse)
library(Seurat)

VersionPdfExt <- paste0(".V", gsub("-", "", Sys.Date()), ".pdf")

if (dir.exists("/Volumes/babs/working/boeings/")){
    hpc.mount <- "/Volumes/babs/working/boeings/"
} else if (dir.exists("Y:/working/boeings/")){
    hpc.mount <- "Y:/working/boeings/"
} else if (dir.exists("/camp/stp/babs/working/boeings/")){
    hpc.mount <- "/camp/stp/babs/working/boeings/"
} else {
    hpc.mount <- ""
}

#Create the environment and load a suitable version of R, e.g. so:
FN <- paste0(hpc.mount, "Projects/reference_data/documentation/BC.parameters.txt")
dbTable <- read.delim(
    FN, 
    sep = "\t",
    stringsAsFactors = F
)

db.pwd <- as.vector(dbTable[1,1])

##                                                                           ##
###############################################################################



# source("assets/scTools.r")
source("assets/SBwebtools.pckg.r")


if (length(.libPaths()) > 2){
    .libPaths(.libPaths()[2:3])
}

ObioFN <- paste0("../", list.files("..")[grep(".bioLOGIC.Robj", list.files(".."))])

if (file.exists(ObioFN)){
    load(paste0(ObioFN))
    print(paste0("Obio object ", Obio@parameterList$localWorkDir, ObioFN, " exists and is loaded."))
} else {
    exit()
}

## Reset paths to local environment
Obio <- setMountingPoint(Obio)
Obio <- setAnalysisPaths(Obio)
Obio <- setCrickGenomeAndGeneNameTable(Obio)
Obio <- createAnalysisFolders(
    Obio,
    baseDir="/camp/stp/babs/working/boeings/Projects/",
    localBaseDir = paste0(hpc.mount, "Projects/")
)
Obio <- setDataBaseParameters(Obio)

##                                                                           ##
###############################################################################

###############################################################################
## Load R-Object                                                             ##

SeuratFN <- paste0(Obio@parameterList$localWorkDir,list.files(Obio@parameterList$localWorkDir)[grep(".Seurat.Robj", list.files(Obio@parameterList$localWorkDir))])


if (file.exists(SeuratFN)){
    load(SeuratFN)
    print(paste0("Obio object ", Obio@parameterList$localWorkDir,SeuratFN, " exists and is loaded."))
    
} else {
    exit()
}


if (Obio@parameterList$scIntegrationMethod == "SCT"){
    resultSlot = "SCT"
} else {
    resultSlot = "RNA"
}

##                                                                           ##
###############################################################################
```

```{r create read-count matrix, eval=TRUE, echo=T, results=F}

###############################################################################
## Create split identity                                                     ##

OsC@meta.data[["bulk_samples"]] <- ""

## naming convention [dataseries]_[sampleGroup]_[replicate] ##

OsC@meta.data[["bulk_samples"]] <- paste0(
    "S_",
    OsC@meta.data$sampleID
)

sampleVec <- unique(OsC@meta.data$bulk_samples)


###############################################################################
## Create replicates
Nreplicates <- 3

for (i in 1:length(sampleVec)){
    repVec <- as.vector(
        OsC@meta.data[OsC@meta.data$bulk_samples == sampleVec[i], "bulk_samples"]
    )
    Nrep <- ceiling(length(repVec)/Nreplicates)
    addVec <- as.vector(NULL, mode = "character")
    for (k in 1:Nreplicates){
        addVec <- c(
            addVec,
            paste0("_", rep(k, Nrep))
        )
        
    }
    addVec <- addVec[1:length(repVec)]
    
    OsC@meta.data[OsC@meta.data$bulk_samples == sampleVec[i], "bulk_samples"] <- paste0(OsC@meta.data[OsC@meta.data$bulk_samples == sampleVec[i], "bulk_samples"], addVec)
    
    
}

## Done creating replicates                                                  ##
###############################################################################

Idents(OsC) <- "bulk_samples"

cluster.averages <- AverageExpression(
    OsC, 
    return.seurat = T,
    slot = "counts",
    assays = "RNA"
)

dfAvgExpr <- data.frame(cluster.averages[["RNA"]]@counts)
dfAvgExpr <- data.frame(apply(dfAvgExpr, 2, ceiling))

dfAvgExpr <- dfAvgExpr + 1

selVec <- c(
    "X",
    names(dfAvgExpr)
)

sampleVec <- names(dfAvgExpr)

dfAvgExpr[["X"]] <- row.names(dfAvgExpr)
dfAvgExpr <- dfAvgExpr[,selVec]

## Change gene names > ENSG/ENSMUSG ##
dfAnno <- unique(Obio@dfGeneAnnotation[,c(Obio@parameterList$primaryAlignmentGeneID, Obio@parameterList$geneIDcolumn)])

dfAnno <- dfAnno[dfAnno[,Obio@parameterList$geneIDcolumn] %in% dfAvgExpr[,"X"] ,]
dfAnno <- dfAnno[!duplicated(dfAnno[,Obio@parameterList$geneIDcolumn]),]

dfAvgExpr <- merge(
    dfAvgExpr, 
    dfAnno, 
    by.x = "X",
    by.y = Obio@parameterList$geneIDcolumn
)



dfAvgExpr[["X"]] <- dfAvgExpr[,Obio@parameterList$primaryAlignmentGeneID]
dfAvgExpr[,Obio@parameterList$primaryAlignmentGeneID] <- NULL

dfRSEM <- dfAvgExpr
row.names(dfRSEM) <- dfRSEM$X
dfRSEM$X <- NULL

Obio@RSEMcountMatrix <- data.matrix(dfRSEM)

## replace gene names with ENSG/ENSMUSG ##

RSEMdir <- paste0(
    Obio@parameterList$workdir,
    "RSEM/"
)

if (!dir.exists(RSEMdir)){
    dir.create(RSEMdir)
}


Obio@parameterList$RSEMcountDataFile <- paste0(
    RSEMdir,
    Obio@parameterList$project_id,
    ".count.data.txt"
)

write.table(
    dfAvgExpr,
    Obio@parameterList$RSEMcountDataFile,
    sep = "\t"
)

##                                                                           ##
###############################################################################

```

```{r create design_file, eval=TRUE, echo=T, results=F}

dfDesign <- data.frame(sample.id = sampleVec)
dfDesign <- completeDesignBasedOnSampleID(dfDesign)
dfDesign[["LRT_sample"]] <- sapply(dfDesign$sample.group, function(x) unlist(strsplit(x, "_"))[2])
Obio@dfDesign <- dfDesign

Obio@dfDesign[["replicate"]] <- paste0(
    "R",
    sapply(
    as.vector(Obio@dfDesign$sample.id),
    function(x) unlist(strsplit(x, "_"))[3]
))

# dfDesign <- addDGEcomparisons2DesignFile(
#     dfDesign = dfDesign,
#     comparisonList = list(
#         "comp_1" = c("Pole4WTp53NULL", "Pole4WTp53WT"),
#         "comp_2" = c("Pole4NULLp53WT", "Pole4WTp53WT"),
#         "comp_3" = c("Pole4NULLp53NULL", "Pole4NULLp53WT"),
#         "comp_4" = c("Pole4NULLp53HET", "Pole4NULLp53WT"),
#         "comp_5" = c("Pole4NULLp53HET", "Pole4WTp53HET"),
#         "comp_6" = c("Pole4NULLp53NULL", "Pole4NULLp53HET")
#     )
# )#

```

```{r do_LRT_data, eval=TRUE, echo=T, results=F}

dfDGEModel <- data.frame(
    testType = c("LRT"),
    name = names(Obio@dfDesign)[grep("LRT_", names(Obio@dfDesign)) ],
    fullModel = c(
        "~LRT_sample + replicate"
    ),
    reducedModel = c(
        "~replicate"
    )
)



###############################################################################
## Do LRT analysis                                                           ##

setGeneric(
    name="doDiffExprAnalysis",
    def=function(
        obj,
        dfDGEModel = NULL,
        createNewResultTable = TRUE,
    ) {
        
        #######################################################################
        ## Ensure result table slot is reset                                 ##
        if (createNewResultTable){
            obj@DEseq2LRTtable <- data.frame(NULL)
        }
        ## Done emptying past results                                        ##
        #######################################################################
        
        
        
        if (!(is.null(dfDGEModel)) > 0){
            for (i in 1:nrow( dfDGEModel)){
                designFormula <- as.formula(as.vector(dfDGEModel[i, "fullModel"]))
                reducedFormula <- as.formula(as.vector(dfDGEModel[i, "reducedModel"]))
                
                selCols <- dfDGEModel[i, "fullModel"]
                selCols <- gsub("~", "", selCols)
                selCols <- unlist(strsplit(selCols, "[+]"))
                selCols <- gsub(" ", "", selCols)
                selCols <- c(
                    "sample.id",
                    selCols
                )
                
                
                # if (obj@parameterList$batchMode){
                #     selCols <- c("sample.id", "sample.group","replicate", LRTdesignCols[i])
                #     designFormula <- as.formula("~ replicate + condition")
                # } else {
                #     selCols <- c("sample.id", "sample.group", LRTdesignCols[i])
                #     designFormula <- as.formula("~ condition")
                # }
                
                colData = unique(obj@dfDesign[, selCols])
                
                selCols <- selCols[selCols %in% names(colData)]
                
                rownames(colData) = as.vector(colData$sample.id)
                #colnames(colData)[1] = "condition"
                for (j in 1:length(selCols)){
                    colData[,selCols[j]] <- as.factor(colData[,selCols[j]])
                }
                
                #Remove superflous rows from colData
                #colData = droplevels(data.frame(colData[colData$condition != "",]))
                #colData <- colData[order(colData$condition),]
                
                ## Extract order for col names ##
                contrasts = sort(unique(obj@dfDesign[,as.vector(dfDGEModel[i, "name"])]), decreasing = FALSE)  
                contrasts = contrasts[contrasts != ""]
                
                ## Remove order suffix
                if (as.vector(dfDGEModel[i, "testType"]) == "Wald"){
                    colData[,as.vector(dfDGEModel[i, "name"])] <- gsub("^1_", "", colData[,as.vector(dfDGEModel[i, "name"])])
                    colData[,as.vector(dfDGEModel[i, "name"])] <- gsub("^2_", "", colData[,as.vector(dfDGEModel[i, "name"])])
                    contrasts <- gsub("^1_", "", contrasts)
                    contrasts <- gsub("^2_", "", contrasts)
                    
                    #Create contrast vector
                    #contrast.vector = c([condition],[1_diff.gene set, e.g. mt],[2_baseline, e.g. wt])
                    #if (contrasts[2] != "scr"){
                    #  contrasts = rev(contrasts)
                    #}
                    sel.col = contrasts
                    
                    contrast.vector = append("condition", contrasts)
                    colName = paste(contrasts, collapse = "_vs_")
                } else {
                    colName = as.vector(dfDGEModel[i, "name"])
                }
                    
                raw.counts.temp = obj@RSEMcountMatrix[,rownames(colData)]
                
                
                dds <- DESeqDataSetFromMatrix(
                    countData = raw.counts.temp,
                    colData   = colData,
                    design    = designFormula
                )
                
               
                
                dds <- DESeq(
                    dds,
                    test = "LRT",
                    parallel = obj@parameterList$parallelProcessing,
                    reduced = reducedFormula
                )
                
                dds <- estimateDispersionsGeneEst(dds)
                dispersions(dds) <- mcols(dds)$dispGeneEst
                
                res <- results(dds)
                
                ###############################################################
                ## Add result to result collection                           ##
                
                #Continue with the differential gene expression analysis
                res = data.frame(res)
                res[[obj@parameterList$primaryAlignmentGeneID]] = rownames(res)
                
                res$stat <- NULL
                
                res$baseMean <- log2(res$baseMean)
                names(res) = gsub(
                    "baseMean", 
                    paste0("contrast_L_lg2BaseMean_", LRTdesignCols[i]),
                    names(res)
                )
                
                names(res) = gsub(
                    "padj", 
                    paste0("contrast_L_padj_", LRTdesignCols[i]), 
                    names(res)
                )
                
                
                
                #Remove all rows without a padj
                padj.col = grep("padj", names(res))[1]
                res[,padj.col][is.na(res[,padj.col])] = ""
                res = res[res[,padj.col] != "", ]
                res[,padj.col] <- as.numeric(res[,padj.col])
                
                ## Add log10p column ##
                padj  <- names(res)[grep("_padj_", names(res))]
                lg10p <- gsub("padj", "lg10p", padj) 
                
                for (z in 1:length(padj)){
                    preprocess <- as.numeric(res[,padj[z]])
                    minNum <- min(preprocess[preprocess != 0])
                    preprocess[preprocess == 0] <- minNum
                    
                    # if (length(grep("padj_LRT", padj[i])) > 0){
                    #     preprocess <- as.numeric(res[,padj[z]])
                    #     minNum <- min(preprocess[preprocess != 0])
                    #     preprocess[preprocess == 0] <- minNum
                    # } else {
                    #     preprocess <- as.numeric(res[,padj[z]])
                    # }
                    
                    temp <- -1*log10(preprocess)
                    #temp[temp >= 50] = 50
                    res[,lg10p[z]] <- temp
                }
                
                col.vector = c(
                    obj@parameterList$primaryAlignmentGeneID,
                    names(res)[grep("contrast", names(res))]
                )
                
                res = res[,col.vector]
                
                ## Make all numeric columns numierc ##
                ## Make all numeric columns numierc ##
                res[,grep("contrast_", names(res))] <- apply(res[,grep("contrast_", names(res))], 2, as.numeric)
                
                ###############################################################
                ## lg10p 0.00 > 0.001                                        ##
                # lg10pCol <- names(res)[grep("lg10p", names(res))]
                # logFCcol <- names(res)[grep("logFC", names(res))]
                # 
                # res[,lg10pCol] <- res[,lg10pCol] + 0.001
                # res[res[,logFCcol] == 0, lg10pCol] <- 0
                
                ## Done                                                      ##
                ###############################################################    
                
                ## Add to result array ##
                if (nrow(obj@DEseq2LRTtable) == 0){
                    obj@DEseq2LRTtable <- res
                } else {
                    obj@DEseq2LRTtable <- merge(
                        obj@DEseq2LRTtable,
                        res, 
                        by.x = obj@parameterList$primaryAlignmentGeneID,
                        by.y = obj@parameterList$primaryAlignmentGeneID,
                        all = TRUE
                    )
                    obj@DEseq2LRTtable[is.na(obj@DEseq2LRTtable)] <- 0
                }
                
                
                ## Done adding to result collection                          ##
                ###############################################################
            } 
            
            
            ####################################
            ## End for loop for LRT         ####
            ####################################
        } 
        
        
        
        ## Done with LRT Analysis                                            ##
        #######################################################################
        
        return(obj)
        
        
    }
)

## Done LRT method                                                       ##
###############################################################################




###############################################################################
## Do differential gene expression                                           ##

setGeneric(
    name="doDGEanalysis_new",
    def=function(
        obj,
        DGEdesignCols = 'names(Obio@dfDesign)[grep("comp_", names(Obio@dfDesign)) ]',
        createNewResultTable = TRUE,
        normaliseAllSamplesTogether = FALSE
        
    ) {
        #######################################################################
        ## Ensure result table slot is reset                                 ##
        if (createNewResultTable){
            obj@DEseq2contrastTable <- data.frame(NULL)
        }
        ## Done emptying past results                                        ##
        #######################################################################
        
        #######################################################################
        ## DGE Analysis                                                      ##
        if (length(DGEdesignCols) > 0){
            for (i in 1:length(DGEdesignCols)){
                if (obj@parameterList$batchMode){
                    selCols <- c("sample.id", "sample.group","replicate", DGEdesignCols[i])
                    designFormula <- as.formula("~ replicate + condition")
                } else {
                    selCols <- c("sample.id", "sample.group", DGEdesignCols[i])
                    designFormula <- as.formula("~ condition")
                }
                
                colData = unique(obj@dfDesign[, selCols])
                rownames(colData) = as.vector(colData$sample.id)
                colnames(colData)[1] = "condition"
                colData[,1] <- colData[,DGEdesignCols[i]]
                
                
                if (obj@parameterList$batchMode){
                    colData$replicate <- as.factor(colData$replicate)
                }
                
                
                if (!normaliseAllSamplesTogether) {
                    colData = droplevels(data.frame(colData[colData$condition != "",]))
                    colData <- colData[order(colData$condition),]
                } else {
                    colData[colData$condition == "", "condition"] <- "rest"
                }
                
                
                colData[,"condition"] = as.factor(colData[,"condition"])
                colData$sample.group <- as.factor(colData$sample.group)
                #colData$sample.group <- as.factor(colData$sample.group)
                
                #Remove superflous rows from colData
                ## Extract order for col names ##
                contrasts = sort(unique(obj@dfDesign[,DGEdesignCols[i]]), decreasing = FALSE)  
                contrasts = contrasts[contrasts != ""]
                
                ## Remove order suffix
                colData$condition <- gsub("^1_", "", colData$condition)
                colData$condition <- gsub("^2_", "", colData$condition)
                contrasts <- gsub("^1_", "", contrasts)
                contrasts <- gsub("^2_", "", contrasts)
                
                #Create contrast vector
                #contrast.vector = c([condition],[1_diff.gene set, e.g. mt],[2_baseline, e.g. wt])
                #if (contrasts[2] != "scr"){
                #  contrasts = rev(contrasts)
                #}
                sel.col = contrasts
                
                contrast.vector = append("condition", contrasts)
                colName = paste(contrasts, collapse = "_vs_")
                
                if (normaliseAllSamplesTogether) {
                    raw.counts.temp = obj@RSEMcountMatrix
                } else {
                    raw.counts.temp = obj@RSEMcountMatrix[,rownames(colData)]    
                }
                
                
                ## Make factor ##
                colData$condition <- as.factor(colData$condition)
                #colData$sample.group <- as.factor(colData$sample.group)
                
                
                
                dds <- DESeqDataSetFromMatrix(
                    countData = raw.counts.temp,
                    colData   = colData,
                    design    = designFormula
                )
                
                #dds$condition <- factor(dds$condition, levels=contrasts)
                dds <- DESeq(
                    dds,
                    test = "Wald",
                    parallel = obj@parameterList$parallelProcessing,
                    betaPrior = obj@parameterList$DEseq2betaPrior
                )
                
                res <- results(dds, contrast = contrast.vector)
                #https://support.bioconductor.org/p/83773/
                #res <- results(dds, contrast=list("conditioncell_type_A","conditioncell_type_B"))
                
                
                #Create MA plot
                library(ggpubr)
                library(ggplot2)
                plotname <- paste0("MAplot_", colName)
                
                tryCatch({
                    obj@plotCollection[[plotname]] <- ggmaplot(
                        res, main = plotname,
                        fdr = 0.05, fc = 4, size = 1,
                        palette = c("#B31B21", "#1465AC", "darkgray"),
                        genenames = as.vector(row.names(res)),
                        legend = "top", top = 5,
                        font.label = c("bold", 5),
                        font.legend = "bold",
                        font.main = "bold",
                        ggtheme = ggplot2::theme_minimal())+
                        theme(plot.title = element_text(hjust = 0.5),
                              panel.border = element_rect(colour = "black", fill=NA, size=1)
                        ) + ylim(-10, 10)
                    
                    
                    #    obj@plotCollection[[plotname]] = print(plotMA(res, main=colName))
                }, 
                error = function(c) "MA plot not produced due to X11 error",
                warning = function(c) "warning",
                message = function(c) "message" 
                )
                
                #Identify most variable genes in the dataset
                #Use sd(row)/mean(row)
                
                #Create PCA plot based on the most variable genes in the dataset
                
                
                
                #######################################################################
                
                #Continue with the differential gene expression analysis
                ## reference https://support.bioconductor.org/p/95695/    
                if (obj@parameterList$DEseq2betaPrior == FALSE) {
                    res <- lfcShrink(dds, coef="log2FoldChange", type="apeglm")
                }    
                
                res = data.frame(res)
                names(res) = paste(names(res), colName, sep="_")
                res[[obj@parameterList$primaryAlignmentGeneID]] = rownames(res)
                
                
                names(res) = gsub("log2FoldChange", "logFC", names(res))
                names(res) = gsub(
                    "logFC", 
                    paste("contrast_", i, "_logFC", sep=""), 
                    names(res)
                )
                
                names(res) = gsub(
                    "padj", 
                    paste("contrast_", i, "_padj", sep=""), 
                    names(res)
                )
                
                names(res) = gsub(
                    "stat", 
                    paste("contrast_", i, "_stat", sep=""), 
                    names(res)
                )
                
                res$baseMean <- log2(res$baseMean)
                names(res) = gsub(
                    "baseMean", 
                    paste("contrast_", i, "_lg2BaseMean", sep=""), 
                    names(res)
                )
                
                #Remove all rows without a padj
                padj.col = grep("padj", names(res))[1]
                res[,padj.col][is.na(res[,padj.col])] = ""
                res = res[res[,padj.col] != "", ]
                res[,padj.col] <- as.numeric(res[,padj.col])
                
                ## Add log10p column ##
                padj  <- names(res)[grep("_padj_", names(res))]
                lg10p <- gsub("padj", "lg10p", padj) 
                
                for (z in 1:length(padj)){
                    preprocess <- as.numeric(res[,padj[z]])
                    minNum <- min(preprocess[preprocess != 0])
                    preprocess[preprocess == 0] <- minNum
                    
                    # if (length(grep("padj_LRT", padj[i])) > 0){
                    #     preprocess <- as.numeric(res[,padj[z]])
                    #     minNum <- min(preprocess[preprocess != 0])
                    #     preprocess[preprocess == 0] <- minNum
                    # } else {
                    #     preprocess <- as.numeric(res[,padj[z]])
                    # }
                    
                    temp <- -1*log10(preprocess)
                    #temp[temp >= 50] = 50
                    res[,lg10p[z]] <- temp
                }
                
                col.vector = c(
                    obj@parameterList$primaryAlignmentGeneID,
                    names(res)[grep("contrast", names(res))]
                )
                
                res = res[,col.vector]
                
                ## Make all numeric columns numeric ##
                res[,grep("contrast_", names(res))] <- apply(res[,grep("contrast_", names(res))], 2, as.numeric)
                
                ###############################################################
                ## lg10p 0.00 > 0.001                                        ##
                # lg10pCol <- names(res)[grep("lg10p", names(res))]
                # logFCcol <- names(res)[grep("logFC", names(res))]
                # 
                # res[,lg10pCol] <- res[,lg10pCol] + 0.001
                # res[res[,logFCcol] == 0, lg10pCol] <- 0
                
                ## Done                                                      ##
                ###############################################################
                
                ###############################################################
                ## Make diagnostic Volcano plot                              ##
                dfVplot <- res
                dfVplot[["Significance"]] <- "NS"
                dfVplot[dfVplot[,grep("padj", names(dfVplot))] < 0.05 & dfVplot[,grep("logFC", names(dfVplot))] > 2, "Significance"] <- "Up"
                dfVplot[dfVplot[,grep("padj", names(dfVplot))] < 0.05 & dfVplot[,grep("logFC", names(dfVplot))] < -2, "Significance"] <- "Down"
                nrow(dfVplot[dfVplot$Significance == "Up",])
                nrow(dfVplot[dfVplot$Significance == "Down",])
                
                dsize <- 1
                alpha <- I(0.5)
                shape <- 21
                
                tryCatch({
                    library(ggplot2)
                    plotname <- paste0("Volcano_Plot_", colName)
                    obj@plotCollection[[plotname]] <- ggplot(
                        data=dfVplot,
                        aes_string(
                            x=names(res)[grep("logFC", names(res))], 
                            y=names(res)[grep("lg10p", names(res))],
                            fill = "Significance", alpha = alpha
                        )
                    ) + geom_vline(xintercept = 0, color = "black", size=0.5
                    ) + geom_hline(yintercept = 0, color = "black", size=0.5
                    ) + geom_vline(xintercept = c(-2,2), color = "red", size=0.5,linetype = 2
                    ) + geom_hline(yintercept = c(1.3), color = "red", size=0.5,linetype = 2
                    ) + geom_point(shape=shape
                    ) + labs(title = plotname, y = "-log10(padjust)"
                    ) +  theme(
                        axis.text.y   = element_text(size=8),
                        axis.text.x   = element_text(size=8),
                        axis.title.y  = element_text(size=8),
                        axis.title.x  = element_text(size=8),
                        axis.line = element_line(colour = "black"),
                        panel.border = element_rect(colour = "black", fill=NA, size=1),
                        plot.title = element_text(hjust = 0.5, size = 12),
                        panel.grid.minor = element_blank()
                    ) + scale_x_continuous(breaks=c(-2,2,seq(-30,30,5))
                    ) + scale_y_continuous(breaks=c(seq(0,400,5))
                    ) + scale_color_manual(values=c("black", "black", "black")
                    ) + scale_fill_manual(values=c("blue", "grey", "red")                       
                    ) + guides(color = FALSE
                    )
                    
                    
                    #obj@plotCollection[[plotname]] = print(plotMA(res, main=colName))
                }, 
                error = function(c) "MA plot not produced due to X11 error",
                warning = function(c) "warning",
                message = function(c) "message" 
                
                )
                ## Done diagnostic Volcano plot                              ##
                ###############################################################
                
                ## Add to result array ##
                if (nrow(obj@DEseq2contrastTable) == 0){
                    obj@DEseq2contrastTable <- res
                } else {
                    obj@DEseq2contrastTable <- merge(
                        obj@DEseq2contrastTable,
                        res, 
                        by.x = obj@parameterList$primaryAlignmentGeneID,
                        by.y = obj@parameterList$primaryAlignmentGeneID,
                        all = TRUE
                    )
                    obj@DEseq2contrastTable[is.na(obj@DEseq2contrastTable)] <- 0
                }
            }
            ####################################
            ## End for loop for DGE         ####
            ####################################
        } ## Ed DGE
        
        
        
        return(obj)  
        
    }
)

## Done LRT/DGE method                                                       ##
###############################################################################


```